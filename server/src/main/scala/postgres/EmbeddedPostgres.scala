package postgres

import zio.*
import zio.process.Command
import _root_.config.{getFreePort, readConfig}
import _root_.persistency.useDataSubDir
import embedded_postgres_config.EmbeddedPostgresConfig
import os.Path

case class PostgresConfig(
    host: String,
    port: Int,
    user: String,
    password: String,
    database: String
)

val dataDirName = "pgdata"

object EmbeddedPostgres:
    private def initEmptyDataDir(embeddedPostgresConfig: EmbeddedPostgresConfig): Task[Unit] = for {
        _ <- ZIO.logInfo(s"Initializing empty dir for embedded Postgres")
        passwordFile <- ZIO.attempt(os.temp(contents = embeddedPostgresConfig.password, perms = os.PermSet.fromString("rw-------")))
        p <- Command(
            "initdb",
            "-D",
            embeddedPostgresConfig.dataDir,
            "--username",
            embeddedPostgresConfig.user,
            "--auth",
            "md5",
            "--pwfile",
            passwordFile.toString
        ).inheritIO.run
        _ <- p.successfulExitCode
        _ <- configure
    } yield ()

    private def prepareDataDir(embeddedPostgresConfig: EmbeddedPostgresConfig): Task[Unit] = for {
        _ <- ZIO.logInfo("Preparing embedded Postgres data directory")
        dataDir <- useDataSubDir(dataDirName)
        _ <- ZIO.logInfo(s"Using embedded Postgres data dir: $dataDir")
        isDataDirEmpty <- ZIO.attempt(os.list(dataDir).isEmpty)
        _ <- initEmptyDataDir(embeddedPostgresConfig).when(isDataDirEmpty)
    } yield ()

    private def configure: Task[Unit] = for {
        _ <- ZIO.logInfo(s"Configuring embedded Postgres")
        postgresqlConfContent <- ZIO.succeed(
            """
              |# DO NOT EDIT THIS FILE BY HAND!
              |# IT IS AUTOGENERATED BY DEKAF - FOR APACHE PULSAR
              |
              |max_connections = 100
              |shared_buffers = 128MB
              |log_line_prefix = 'postgres %m [%p] %q%u@%d '
              |log_timezone = 'UTC'
              |datestyle = 'iso, mdy'
              |timezone = 'UTC'
              |lc_messages = 'en_US.UTF-8'
              |lc_monetary = 'en_US.UTF-8'
              |lc_numeric = 'en_US.UTF-8'
              |lc_time = 'en_US.UTF-8'
              |default_text_search_config = 'pg_catalog.english'
              |log_min_messages = warning
              |log_connections = 1
              |log_disconnections = 1
              |""".stripMargin
        )
        dataDir <- useDataSubDir(dataDirName)
        posgresqlConfPath = dataDir / "postgresql.conf"
        _ <- ZIO.attempt(os.remove(posgresqlConfPath))
        _ <- ZIO.attempt(os.write(posgresqlConfPath, postgresqlConfContent))
    } yield ()

    case class StartPostgresResult(process: zio.process.Process, config: PostgresConfig)
    private def startPostgres(embeddedPostgresConfig: EmbeddedPostgresConfig): Task[StartPostgresResult] = for {
        config <- readConfig
        _ <- ZIO.logInfo(s"Starting embedded Postgres")
        _ <- configure
        process <- Command("postgres", "-D", embeddedPostgresConfig.dataDir, "-p", embeddedPostgresConfig.port.toString)
            .redirectErrorStream(true)
            .inheritIO
            .run
        postgresConfig <- ZIO.attempt {
            PostgresConfig(
                host = embeddedPostgresConfig.host,
                port = embeddedPostgresConfig.port,
                user = embeddedPostgresConfig.user,
                password = embeddedPostgresConfig.password,
                database = config.postgresDatabase.get
            )
        }
        _ <- process.successfulExitCode.forkDaemon
        _ <- waitPostgresIsReady(postgresConfig)
    } yield StartPostgresResult(process, postgresConfig)

    def waitPostgresIsReady(config: PostgresConfig): Task[Unit] =
        val check = for {
            process <- Command("pg_isready", "-h", config.host, "-p", config.port.toString, "-U", config.user).inheritIO.run
            _ <- process.successfulExitCode
        } yield ()

        for {
            _ <- check.retry(Schedule.recurs(20) && Schedule.spaced(1.second))
            _ <- ZIO.logInfo(s"Embedded Postgres is ready.")
        } yield ()

    def run: Task[PostgresConfig] = for
        config <- readConfig
        freePort <- ZIO.attempt(getFreePort)
        embeddedPostgresConfig <- ZIO.succeed(
            EmbeddedPostgresConfig(
                host = "0.0.0.0",
                port = freePort,
                dataDir = s"${config.dataDir.get}/pgdata",
                user = config.postgresUser.get,
                password = config.postgresPassword.get
            )
        )
        _ <- prepareDataDir(embeddedPostgresConfig)
        startPostgresResult <- startPostgres(embeddedPostgresConfig)
    yield startPostgresResult.config
